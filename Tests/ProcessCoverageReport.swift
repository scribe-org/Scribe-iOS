// SPDX-License-Identifier: GPL-3.0-or-later

/**
 * Processes the coverage report generated by xcrun xccov on the xcodebuild testing coverage report.
 */

import Foundation

struct Function: Codable {
	let coveredLines: Int
	let executableLines: Int
	let executionCount: Int
	let lineCoverage: Double
	let lineNumber: Int
	let name: String
}

struct File: Codable {
	let coveredLines: Int
	let executableLines: Int
	let functions: [Function]
	let lineCoverage: Double
	let name: String
	let path: String
}

struct Target: Codable {
	let buildProductPath: String
	let coveredLines: Int
	let executableLines: Int
	let files: [File]
}

struct CoverageReport: Codable {
	let coveredLines: Int
	let executableLines: Int
	let lineCoverage: Double
	let targets: [Target]
}

func loadCoverageReport(from filePath: String) -> CoverageReport? {
	do {
		let data: Data = try Data(contentsOf: URL(fileURLWithPath: filePath))
		let decoder: JSONDecoder = JSONDecoder()
		let report: CoverageReport = try decoder.decode(CoverageReport.self, from: data)
		return report
	} catch {
		print("Failed to load or decode JSON: \(error)")
		return nil
	}
}

func printCoverageReport(_ report: CoverageReport, threshold: Double) {
	var reportDict: [String: [String: Double]] = [:]
	for target: Target in report.targets {
		for file: File in target.files {
			if !file.path.contains("Build/SourcePackages") && !file.path.contains("/Tests/") {
				reportDict[file.path.components(separatedBy: "scribe-org/Scribe-iOS")[1]] = [
					"coveredLines": Double(file.coveredLines),
					"executableLines": Double(file.executableLines),
					"lineCoverage": file.lineCoverage
				]
			}
		}
	}

	let maxFileNameLength: Int = reportDict.keys.map { $0.count }.max() ?? 0

	var coveredLinesProject: Double = 0.0
	var executableLinesProject: Double = 0.0

	print("\("\nFile".padding(toLength: maxFileNameLength, withPad: " ", startingAt: 0))   Cover")
	print("\("".padding(toLength: maxFileNameLength, withPad: "-", startingAt: 0))-------")
	for (f, c) in reportDict.sorted(by: { $0.0 < $1.0 }) {
		let fileNamePadded: String = f.padding(toLength: maxFileNameLength, withPad: " ", startingAt: 0)
		print("\(fileNamePadded)  \(String(format: "%.0f", c["lineCoverage"]! * 100))%")
		coveredLinesProject += c["coveredLines"]!
		executableLinesProject += c["executableLines"]!
	}

	let lineCoverageProject: Double = coveredLinesProject / executableLinesProject * 100

	print("\("".padding(toLength: maxFileNameLength, withPad: "-", startingAt: 0))-------")
	print("\("Total".padding(toLength: maxFileNameLength, withPad: " ", startingAt: 0))  \(String(format: "%.0f", lineCoverageProject))%\n")

	if lineCoverageProject >= threshold {
		if threshold > 0 {
			print("Required test coverage of \(threshold)% reached. Total coverage: \(String(format: "%.2f", lineCoverageProject))%\n")
		}
		exit(0)
	} else {
		print("\nError: Code coverage did not meet the \(threshold)% threshold.\n")
		exit(1)
	}
}

guard CommandLine.arguments.count >= 2 else {
	print("Usage: \(CommandLine.arguments[0]) <coverage-json-file> [coverage-threshold]"); exit(1)
}

let coverageJSONFile: String = CommandLine.arguments[1]
let coverageThreshold: Double
if CommandLine.arguments.count == 3 {
	coverageThreshold = Double(CommandLine.arguments[2]) ?? 0.0
} else {
	coverageThreshold = 0.0
}

if let report: CoverageReport = loadCoverageReport(from: coverageJSONFile) {
	printCoverageReport(report, threshold: coverageThreshold)
} else {
	print("Failed to load the coverage report.")
	exit(1)
}
